**2.1) What software packages are loaded on the cluster by default and which versions are available?**  

> **Before loading the Environment Default Loaded Software Packages:**  
> - None  
>  
> **After loading the Environment Default Loaded Software Packages:**  
> - gcc/14.1.0-6un3o62  
> - python/3.11.9-dntozhq  
> - gdb/14.2-fzhnscn  
> - git/2.45.2-kedihkx  
> - nano/8.0-g6apsk3  
> - vim/9.1.0437-j5ute6t  
>  
> **Available Versions (Excerpt from module avail):**  
> - **gcc:**  
>   - gcc/14.1.0-6un3o62  
>   - gcc/12.4.0-cy5ltpz  
> - **python:**  
>   - python/3.11.9-dntozhq  
> - **gdb:**  
>   - gdb/14.2-fzhnscn  
> - **git:**  
>   - git/2.45.2-kedihkx  
>   - git-lfs/3.5.1-xzykim4  
> - **nano:**  
>   - nano/8.0-g6apsk3  
> - **vim:**  
>   - vim/9.1.0437-j5ute6t  

---

**2.2) What commands would be required to load and then unload a fictitious module foobar?**  

> `module load foobar`  
> `module unload foobar`  

---

**2.3) Is there a way to unload all loaded modules at once with a single command?**  

> `module purge`  

---

**2.4) How can you display more information about a particular module?**  
  
> `module show <module_name>`  

---

**3.1) With which you can display the path of an application. Why does this not work for the cd command? (Hint: man bash)**  
 
> **Shell Builtin:**  
> cd is implemented as a shell builtin command within Bash, meaning it is integrated directly into the shell rather than existing as an external program in the file system.  
>  
> **which Search Scope:**  
> The `which` command searches through the PATH for executables but does not consider shell builtins. Hence, if we run:    
> `which cd`    
> it might show an external `/usr/bin/cd`, but in practice, this is not the command the shell uses when we type `cd`. Instead, Bash uses its internal builtin, which does not appear in any directory on our file system.  
>  
> To check what Bash is really using, we need to type:    
> `type cd`    
> which will typically report:  
> _cd is a function provided by the shell._  

---

**3.2) Why does changing the working directory only work with `cd` but not with `/usr/bin/cd`?**  
 
> - `cd` is a shell builtin, so it executes inside our current shell process and changes *that* process’s working directory.  
> - An external `/usr/bin/cd` (if it existed) would run in a child process, change the child’s directory, then exit—leaving our interactive shell’s directory unchanged.  
>  
> **to Verify this:**  
> - `type cd` → _cd ist eine von der Shell mitgelieferte Funktion._  
> - `which cd` → `/usr/bin/cd`  

---

**3.3) What strikes your attention about the three sizes?**  
 
> **Directory Size (1):**  
> The directory’s listed size (1) represents only the minimal space allocated for its metadata (i.e., the structure holding the list of files) rather than the combined size of the files within it.  
>  
> **File Size (256K):**  
> The file `archive/random` is 256K in size, showing the actual amount of data stored. This size reflects the content generated by writing random data.  
>  
> **Archive File Size (260K):**  
> The tar archive `archive.tar` is 260K, slightly larger than the random file. This difference is due to the additional tar overhead that records metadata such as filenames, permissions, and timestamps.  

---

**3.4) Is it possible to create a compressed archive (archive.tar.gz) with only the tar command? How should this command have looked like?**  
  
> Yes, it’s possible to create a compressed archive using only the tar command with its built-in gzip option. The command is:  
> `tar -czf archive.tar.gz archive`  
>  
> **Options:**  
> - `-c`: Creates a new archive.  
> - `-z`: Compresses the archive using gzip.  
> - `-f`: Specifies the filename of the archive.  
>  
> This single command bundles the `archive` directory into `archive.tar.gz` and applies gzip compression at the same time.

